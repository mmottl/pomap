<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Pomap_intf.PARTIAL_ORDER.html">
<link rel="Up" href="Pomap_intf.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Display_hasse_impl" rel="Chapter" href="Display_hasse_impl.html">
<link title="Display_hasse_intf" rel="Chapter" href="Display_hasse_intf.html">
<link title="Pomap_impl" rel="Chapter" href="Pomap_impl.html">
<link title="Pomap_intf" rel="Chapter" href="Pomap_intf.html">
<link title="Ptset" rel="Chapter" href="Ptset.html">
<link title="Store_impl" rel="Chapter" href="Store_impl.html">
<link title="Store_intf" rel="Chapter" href="Store_intf.html"><link title="Modules and types" rel="Section" href="#6_Modulesandtypes">
<link title="Map-constructors " rel="Section" href="#6_Mapconstructors">
<link title="Information on maps" rel="Section" href="#6_Informationonmaps">
<link title="Adding and removing" rel="Section" href="#6_Addingandremoving">
<link title="Scanning and searching" rel="Section" href="#6_Scanningandsearching">
<link title="Iterators" rel="Section" href="#6_Iterators">
<link title="Set-like map-operations" rel="Section" href="#6_Setlikemapoperations">
<link title="Node-creators and accessors" rel="Section" href="#6_Nodecreatorsandaccessors">
<link title="Map-accessors" rel="Section" href="#6_Mapaccessors">
<link title="Operations over equivalences of data elements" rel="Section" href="#6_Operationsoverequivalencesofdataelements">
<link title="Unsafe operations - USE WITH CAUTION!" rel="Section" href="#6_UnsafeoperationsUSEWITHCAUTION">
<title>Pomap_intf.POMAP</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Pomap_intf.PARTIAL_ORDER.html" title="Pomap_intf.PARTIAL_ORDER">Previous</a>
&nbsp;<a class="up" href="Pomap_intf.html" title="Pomap_intf">Up</a>
&nbsp;</div>
<h1>Module type <a href="type_Pomap_intf.POMAP.html">Pomap_intf.POMAP</a></h1>

<pre><span class="keyword">module type</span> POMAP = <code class="code">sig</code> <a href="Pomap_intf.POMAP.html">..</a> <code class="code">end</code></pre><div class="info modtype top">
Interface to partially ordered maps<br>
</div>
<hr width="100%">
<br>
<h6 id="6_Modulesandtypes">Modules and types</h6><br>

<pre><span class="keyword">module</span> <a href="Pomap_intf.POMAP.Store.html">Store</a>: <code class="type"><a href="Store_intf.STORE.html">Store_intf.STORE</a></code><code class="type"> </code></pre><div class="info">
Store module used to store nodes of the partially ordered map.
</div>

<pre><span id="TYPEkey"><span class="keyword">type</span> <code class="type"></code>key</span> </pre>
<div class="info ">
Type of map keys<br>
</div>


<pre><span id="TYPEnode"><span class="keyword">type</span> <code class="type">+'a</code> node</span> </pre>
<div class="info ">
Type of nodes in the partially ordered map<br>
</div>


<pre><span id="TYPEpomap"><span class="keyword">type</span> <code class="type">+'a</code> pomap</span> </pre>
<div class="info ">
Type of partially ordered maps<br>
</div>


<pre><code><span id="TYPEadd_find_result"><span class="keyword">type</span> <code class="type">'a</code> add_find_result</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTadd_find_result.Found"><span class="constructor">Found</span></span> <span class="keyword">of</span> <code class="type">Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTadd_find_result.Added"><span class="constructor">Added</span></span> <span class="keyword">of</span> <code class="type">Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> * 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></code></td>

</tr></table>

<div class="info ">
Type of result originating from an <code class="code">add_find</code> operation<br>
</div>

<br>
<h6 id="6_Mapconstructors">Map-constructors </h6><br>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
The empty partially ordered map.<br>
</div>

<pre><span id="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -> 'a -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">singleton k el</code><br>
<b>Returns</b> a partially ordered map containing as only
      binding the one from <code class="code">k</code> to <code class="code">el</code>.<br>
</div>
<br>
<h6 id="6_Informationonmaps">Information on maps</h6><br>

<pre><span id="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> bool</code></pre><div class="info ">
<code class="code">is_empty pm</code> tests whether partially ordered map <code class="code">pm</code> is empty.<br>
</div>

<pre><span id="VALcardinal"><span class="keyword">val</span> cardinal</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> int</code></pre><div class="info ">
<code class="code">cardinal pm</code><br>
<b>Returns</b> the number of elements in <code class="code">pm</code>.<br>
</div>
<br>
<h6 id="6_Addingandremoving">Adding and removing</h6><br>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">add k el pm</code><br>
<b>Returns</b> a partially ordered map containing the same
      bindings as <code class="code">pm</code>, plus a binding of <code class="code">k</code> to <code class="code">el</code>. If <code class="code">k</code> was already
      bound in <code class="code">pm</code>, its previous binding disappears.<br>
</div>

<pre><span id="VALadd_node"><span class="keyword">val</span> add_node</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">add_node node pm</code><br>
<b>Returns</b> a partially ordered map containing
      the same bindings as <code class="code">pm</code> plus a binding as represented by
      <code class="code">node</code>. If the associated key already existed in <code class="code">pm</code>, its previous
      binding disappears.<br>
</div>

<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">remove k pm</code><br>
<b>Returns</b> a map containing the same bindings as
      <code class="code">pm</code> except for the node with key <code class="code">k</code>.<br>
</div>

<pre><span id="VALremove_node"><span class="keyword">val</span> remove_node</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">remove_node node pm</code><br>
<b>Returns</b> a map containing the same bindings as
      <code class="code">pm</code> except for the one with the key of <code class="code">node</code>.<br>
</div>

<pre><span id="VALremove_ix"><span class="keyword">val</span> remove_ix</span> : <code class="type">Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">remove_ix ix pm</code><br>
<b>Raises</b> <code>Not_found</code> if <code class="code">ix</code> does not index any node.<br>
<b>Returns</b> a map containing the same bindings as
      <code class="code">pm</code> except for the node indexed by <code class="code">ix</code>.<br>
</div>

<pre><span id="VALtake"><span class="keyword">val</span> take</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> * 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">take k pm</code><br>
<b>Raises</b> <code>Not_found</code> if there is no binding for <code class="code">key</code>.<br>
<b>Returns</b> a tuple <code class="code">(ix, node, map)</code>, where <code class="code">ix</code> is
      the index of the <code class="code">node</code> associated with key <code class="code">k</code> in <code class="code">pm</code>, and <code class="code">map</code>
      is <code class="code">pm</code> without this element.<br>
</div>

<pre><span id="VALtake_ix"><span class="keyword">val</span> take_ix</span> : <code class="type">Store.Ix.t -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> * 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">take_ix ix pm</code><br>
<b>Raises</b> <code>Not_found</code> if <code class="code">ix</code> does not index any node.<br>
<b>Returns</b> a tuple <code class="code">(n, m)</code>, where <code class="code">n</code> is the node
      associated with index <code class="code">ix</code>, and <code class="code">m</code> is a map without this element.<br>
</div>

<pre><span id="VALadd_find"><span class="keyword">val</span> add_find</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEadd_find_result">add_find_result</a></code></pre><div class="info ">
<code class="code">add_find k el pm</code> similar to <code class="code">add</code>, but if the binding did already
      exist, then <code class="code">Found (ix, node)</code> will be returned to indicate the
      index and node under which key <code class="code">k</code> is bound. Otherwise <code class="code">Added
      (new_ix, new_pm)</code> will be returned to indicate that <code class="code">k</code> was bound
      under new index <code class="code">new_ix</code> in the partially ordered map <code class="code">new_pm</code>.<br>
</div>

<pre><span id="VALadd_fun"><span class="keyword">val</span> add_fun</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a -> ('a -> 'a) -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">add_fun k el f pm</code> similar to <code class="code">add</code>, but if the binding already
      existed, then function <code class="code">f</code> will be applied to the previously bound
      data. Otherwise the binding will be added as in <code class="code">add</code>.<br>
</div>
<br>
<h6 id="6_Scanningandsearching">Scanning and searching</h6><br>

<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> bool</code></pre><div class="info ">
<code class="code">mem k pm</code><br>
<b>Returns</b> <code class="code">true</code> if <code class="code">pm</code> contains a binding for key <code class="code">k</code>
      and <code class="code">false</code> otherwise.<br>
</div>

<pre><span id="VALmem_ix"><span class="keyword">val</span> mem_ix</span> : <code class="type">Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> bool</code></pre><div class="info ">
<code class="code">mem el pm</code><br>
<b>Returns</b> <code class="code">true</code> if <code class="code">pm</code> contains a binding for data
      element <code class="code">el</code> and <code class="code">false</code> otherwise.<br>
</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">find k pm</code><br>
<b>Raises</b> <code>Not_found</code> if no such binding exists.<br>
<b>Returns</b> a tuple <code class="code">(ix, node)</code>, where <code class="code">ix</code> is the index
      of key <code class="code">k</code> and <code class="code">node</code> its associated node in map <code class="code">pm</code>.<br>
</div>

<pre><span id="VALfind_ix"><span class="keyword">val</span> find_ix</span> : <code class="type">Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">find_ix ix pm</code><br>
<b>Raises</b> <code>Not_found</code> if such a node does not exist.<br>
<b>Returns</b> the node associated with index <code class="code">ix</code> in map <code class="code">pm</code>.<br>
</div>

<pre><span id="VALchoose"><span class="keyword">val</span> choose</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">choose pm</code><br>
<b>Raises</b> <code>Not_found</code> if <code class="code">pm</code> is empty.<br>
<b>Returns</b> a tuple <code class="code">(ix, node)</code>, where <code class="code">ix</code> is the
      index of the <code class="code">node</code> of some unspecified element in <code class="code">pm</code>.<br>
</div>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> bool) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">filter p pm</code><br>
<b>Returns</b> the map of all elements in <code class="code">pm</code> that
      satisfy <code class="code">p</code>.<br>
</div>

<pre><span id="VALpartition"><span class="keyword">val</span> partition</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> bool) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> * 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">partition p pm</code><br>
<b>Returns</b> a pair of maps <code class="code">(pm1, pm2)</code>, where
      <code class="code">pm1</code> is the map of all the elements of <code class="code">pm</code> that satisfy the
      predicate <code class="code">p</code>, and <code class="code">pm2</code> is the map of all the elements of <code class="code">pm</code>
      that do not satisfy <code class="code">p</code>.<br>
</div>
<br>
<h6 id="6_Iterators">Iterators</h6><br>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> unit) -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> unit</code></pre><div class="info ">
<code class="code">iter f pm</code> applies <code class="code">f</code> to all bound nodes in map <code class="code">pm</code>.
      The order in which the nodes are passed to <code class="code">f</code> is unspecified. Only
      current bindings are presented to <code class="code">f</code>: bindings hidden by more
      recent bindings are not passed to <code class="code">f</code>.<br>
</div>

<pre><span id="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> unit) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> unit</code></pre><div class="info ">
<code class="code">iteri f pm</code> same as <a href="Pomap_intf.POMAP.html#VALiter"><code class="code">Pomap_intf.POMAP.iter</code></a>, but function <code class="code">f</code> also receives
      the index associated with the nodes.<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">map f pm</code><br>
<b>Returns</b> a map with all nodes in <code class="code">pm</code> mapped from
      their original value to identical nodes whose data element is in
      the codomain of <code class="code">f</code>. The order in which nodes are passed to <code class="code">f</code>
      is unspecified.<br>
</div>

<pre><span id="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">mapi f pm</code> same as <a href="Pomap_intf.POMAP.html#VALmap"><code class="code">Pomap_intf.POMAP.map</code></a>, but function <code class="code">f</code> also receives
      the index associated with the nodes.<br>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">fold f pm a</code> computes <code class="code">(f nN ... (f n1 a) ...)</code>, where <code class="code">n1 ... nN</code>
      are the nodes in map <code class="code">pm</code>. The order in which the nodes are
      presented to <code class="code">f</code> is unspecified.<br>
</div>

<pre><span id="VALfoldi"><span class="keyword">val</span> foldi</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">foldi f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALfold"><code class="code">Pomap_intf.POMAP.fold</code></a>, but function <code class="code">f</code> also receives
      the index associated with the nodes.<br>
</div>

<pre><span id="VALtopo_fold"><span class="keyword">val</span> topo_fold</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">topo_fold f pm a</code> computes <code class="code">(f nN ... (f n1 a) ...)</code>, where
      <code class="code">n1 ... nN</code> are the nodes in map <code class="code">pm</code> sorted in ascending
      topological order. Slower than <code class="code">fold</code>.<br>
</div>

<pre><span id="VALtopo_foldi"><span class="keyword">val</span> topo_foldi</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">topo_foldi f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALtopo_fold"><code class="code">Pomap_intf.POMAP.topo_fold</code></a>, but function <code class="code">f</code>
      also receives the index associated with the nodes.<br>
</div>

<pre><span id="VALtopo_fold_ix"><span class="keyword">val</span> topo_fold_ix</span> : <code class="type">(Store.Ix.t -> 'b -> 'b) -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">topo_fold_ix f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALtopo_fold"><code class="code">Pomap_intf.POMAP.topo_fold</code></a>, but function <code class="code">f</code>
      only receives the index associated with the nodes.<br>
</div>

<pre><span id="VALrev_topo_fold"><span class="keyword">val</span> rev_topo_fold</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">rev_topo_fold f pm a</code> computes <code class="code">(f nN ... (f n1 a) ...)</code>, where
      <code class="code">n1 ... nN</code> are the nodes in map <code class="code">pm</code> sorted in descending
      topological order. Slower than <code class="code">fold</code>.<br>
</div>

<pre><span id="VALrev_topo_foldi"><span class="keyword">val</span> rev_topo_foldi</span> : <code class="type">(Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">rev_topo_foldi f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALrev_topo_fold"><code class="code">Pomap_intf.POMAP.rev_topo_fold</code></a>, but function <code class="code">f</code>
      also receives the index associated with the nodes.<br>
</div>

<pre><span id="VALrev_topo_fold_ix"><span class="keyword">val</span> rev_topo_fold_ix</span> : <code class="type">(Store.Ix.t -> 'b -> 'b) -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">rev_topo_fold_ix f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALrev_topo_fold"><code class="code">Pomap_intf.POMAP.rev_topo_fold</code></a>, but function <code class="code">f</code>
      only receives the index associated with the nodes.<br>
</div>

<pre><span id="VALchain_fold"><span class="keyword">val</span> chain_fold</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> list -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">chain_fold f pm a</code> computes <code class="code">(f cN ... (f c1 a) ...)</code>, where
      <code class="code">c1 ... cN</code> are the ascending chaines of nodes in map <code class="code">pm</code>. Only
      useful for small maps, because of potentially exponential
      complexity.<br>
</div>

<pre><span id="VALchain_foldi"><span class="keyword">val</span> chain_foldi</span> : <code class="type">((Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a>) list -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">chain_foldi f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALchain_fold"><code class="code">Pomap_intf.POMAP.chain_fold</code></a>, but function <code class="code">f</code>
      receives chains including the index associated with the nodes.<br>
</div>

<pre><span id="VALrev_chain_fold"><span class="keyword">val</span> rev_chain_fold</span> : <code class="type">('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> list -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">rev_chain_fold f pm a</code> computes <code class="code">(f cN ... (f c1 a) ...)</code>, where
      <code class="code">c1 ... cN</code> are the descending chaines of nodes in map <code class="code">pm</code>. Only
      useful for small maps, because of potentially exponential
      complexity.<br>
</div>

<pre><span id="VALrev_chain_foldi"><span class="keyword">val</span> rev_chain_foldi</span> : <code class="type">((Store.Ix.t * 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a>) list -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">rev_chain_foldi f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALrev_chain_fold"><code class="code">Pomap_intf.POMAP.rev_chain_fold</code></a>, but function <code class="code">f</code>
      receives chains including the index associated with the nodes.<br>
</div>
<br>
<h6 id="6_Setlikemapoperations">Set-like map-operations</h6><br>

<pre><span id="VALunion"><span class="keyword">val</span> union</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">union pm1 pm2</code> merges <code class="code">pm1</code> and <code class="code">pm2</code>, preserving the
      bindings of <code class="code">pm1</code>.<br>
</div>

<pre><span id="VALinter"><span class="keyword">val</span> inter</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">inter pm1 pm2</code> intersects <code class="code">pm1</code> and <code class="code">pm2</code>, preserving the
      bindings of <code class="code">pm1</code>.<br>
</div>

<pre><span id="VALdiff"><span class="keyword">val</span> diff</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">diff pm1 pm2</code> removes all elements of <code class="code">pm2</code> from <code class="code">pm1</code>.<br>
</div>
<br>
<h6 id="6_Nodecreatorsandaccessors">Node-creators and accessors</h6><br>

<pre><span id="VALcreate_node"><span class="keyword">val</span> create_node</span> : <code class="type"><a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -><br>       'a -> Store.Ix.Set.t -> Store.Ix.Set.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">create_node k el sucs prds</code><br>
<b>Returns</b> a node with key <code class="code">k</code>, data
      element <code class="code">el</code>, successors <code class="code">sucs</code> and predecessors <code class="code">prds</code>.<br>
</div>

<pre><span id="VALget_key"><span class="keyword">val</span> get_key</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> <a href="Pomap_intf.POMAP.html#TYPEkey">key</a></code></pre><div class="info ">
<code class="code">get_key n</code><br>
<b>Returns</b> the key associated with node <code class="code">n</code>.<br>
</div>

<pre><span id="VALget_el"><span class="keyword">val</span> get_el</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'a</code></pre><div class="info ">
<code class="code">get_el n</code><br>
<b>Returns</b> the data element associated with node <code class="code">n</code>.<br>
</div>

<pre><span id="VALget_sucs"><span class="keyword">val</span> get_sucs</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> Store.Ix.Set.t</code></pre><div class="info ">
<code class="code">get_sucs n</code><br>
<b>Returns</b> the successors associated with node <code class="code">n</code>.<br>
</div>

<pre><span id="VALget_prds"><span class="keyword">val</span> get_prds</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> Store.Ix.Set.t</code></pre><div class="info ">
<code class="code">get_prds n</code><br>
<b>Returns</b> the predecessors associated with node <code class="code">n</code>.<br>
</div>

<pre><span id="VALset_key"><span class="keyword">val</span> set_key</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> <a href="Pomap_intf.POMAP.html#TYPEkey">key</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">set_key n k</code> sets the key of node <code class="code">n</code> to <code class="code">k</code> and returns new node.<br>
</div>

<pre><span id="VALset_el"><span class="keyword">val</span> set_el</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'a -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">set_el n el</code> sets the data element of node <code class="code">n</code> to <code class="code">el</code> and
      returns new node.<br>
</div>

<pre><span id="VALset_sucs"><span class="keyword">val</span> set_sucs</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> Store.Ix.Set.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">set_sucs n sucs</code> set the successors of node <code class="code">n</code> to <code class="code">sucs</code> and
      returns new node.<br>
</div>

<pre><span id="VALset_prds"><span class="keyword">val</span> set_prds</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> Store.Ix.Set.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">set_prds n prds</code> set the predecessors of node <code class="code">n</code> to <code class="code">prds</code>
      and returns new node.<br>
</div>
<br>
<h6 id="6_Mapaccessors">Map-accessors</h6><br>

<pre><span id="VALget_nodes"><span class="keyword">val</span> get_nodes</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> Store.t</code></pre><div class="info ">
<code class="code">get_nodes pm</code><br>
<b>Returns</b> the store of nodes associated
      with partially ordered map <code class="code">pm</code>. This store represents the
      Hasse-graph of the nodes partially ordered by their keys.<br>
</div>

<pre><span id="VALget_top"><span class="keyword">val</span> get_top</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> Store.Ix.Set.t</code></pre><div class="info ">
<code class="code">get_top pm</code><br>
<b>Returns</b> the set of node indices of nodes that are
      greater than any other node in <code class="code">pm</code> but themselves.<br>
</div>

<pre><span id="VALget_bot"><span class="keyword">val</span> get_bot</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> Store.Ix.Set.t</code></pre><div class="info ">
<code class="code">get_bot pm</code><br>
<b>Returns</b> the set of node indices of nodes that are
      lower than any other node in <code class="code">pm</code> but themselves.<br>
</div>
<br>
<h6 id="6_Operationsoverequivalencesofdataelements">Operations over equivalences of data elements</h6><br>

<pre><span id="VALremove_eq_prds"><span class="keyword">val</span> remove_eq_prds</span> : <code class="type">('a -> 'a -> bool) -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">remove_eq_prds eq pm</code><br>
<b>Returns</b> a map containing the same
      bindings as <code class="code">pm</code> except for nodes whose non-empty predecessors
      all have the same data element as identified by <code class="code">eq</code>.<br>
</div>

<pre><span id="VALfold_eq_classes"><span class="keyword">val</span> fold_eq_classes</span> : <code class="type">('a -> 'a -> bool) -><br>       ('a -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">fold_eq_classes eq f pm a</code> factorizes <code class="code">pm</code> into maximal
      equivalence classes of partial orders: all bindings in each
      class have equivalent data elements as identified by <code class="code">eq</code> and
      are connected in the original Hasse-diagram. This function then
      computes <code class="code">(f ec_elN ecN ... (f ec_el1 ec1 a))</code>, where <code class="code">ec1 ... ecN</code>
      are the mentioned equivalence classes in unspecified order, and
      <code class="code">ec_el1 ... ec_elN</code> are their respective common data elements.<br>
</div>

<pre><span id="VALfold_split_eq_classes"><span class="keyword">val</span> fold_split_eq_classes</span> : <code class="type">('a -> 'a -> bool) -><br>       ('a -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">fold_split_eq_classes eq f pm a</code> same as <a href="Pomap_intf.POMAP.html#VALfold_eq_classes"><code class="code">Pomap_intf.POMAP.fold_eq_classes</code></a>,
      but the equivalence classes are split further so that no element
      of other classes would fit between its bottom and top elements.
      It is unspecified how non-conflicting elements are assigned to
      upper or lower classes!<br>
</div>

<pre><span id="VALpreorder_eq_classes"><span class="keyword">val</span> preorder_eq_classes</span> : <code class="type">('a -> 'a -> bool) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> list</code></pre><div class="info ">
<code class="code">preorder_eq_classes eq pm</code><br>
<b>Returns</b> a preordered list of
      equivalence classes, the latter being defined as in
      <code class="code">fold_split_eq_classes</code>.<br>
</div>

<pre><span id="VALtopo_fold_reduced"><span class="keyword">val</span> topo_fold_reduced</span> : <code class="type">('a -> 'a -> bool) -><br>       ('a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'b -> 'b) -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> 'b -> 'b</code></pre><div class="info ">
<code class="code">topo_fold_reduced eq f pm a</code> computes <code class="code">(f nN ... (f n1 a) ...)</code>,
      where <code class="code">n1 ... nN</code> are those nodes in map <code class="code">pm</code> sorted in ascending
      topological order, whose data element is equivalent as defined by
      <code class="code">eq</code> to the one of lower elements if there are no intermediate
      elements that violate this equivalence.<br>
</div>
<br>
<h6 id="6_UnsafeoperationsUSEWITHCAUTION">Unsafe operations - USE WITH CAUTION!</h6><br>

<pre><span id="VALunsafe_update"><span class="keyword">val</span> unsafe_update</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       Store.Ix.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">unsafe_update pm ix node</code> updates the node associated with node
      index <code class="code">ix</code> in map <code class="code">pm</code> with <code class="code">node</code>. The Hasse-diagram associated
      with the partially ordered map <code class="code">pm</code> may become inconsistent if
      the new node violates the partial order structure. This can lead
      to unpredictable results with other functions!<br>
</div>

<pre><span id="VALunsafe_set_nodes"><span class="keyword">val</span> unsafe_set_nodes</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -><br>       'a <a href="Pomap_intf.POMAP.html#TYPEnode">node</a> Store.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">unsafe_set_nodes pm s</code> updates the node store associated with map
      <code class="code">pm</code> with <code class="code">s</code>.  This assumes that <code class="code">s</code> stores a consistent
      Hasse-diagram of nodes.<br>
</div>

<pre><span id="VALunsafe_set_top"><span class="keyword">val</span> unsafe_set_top</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> Store.Ix.Set.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">unsafe_set_top pm set</code> updates the index of top nodes in
      map <code class="code">pm</code> with <code class="code">set</code>.  This assumes that the nodes referenced by
      the node indices in <code class="code">set</code> do not violate the properties of the
      Hasse-diagram of <code class="code">pm</code>.<br>
</div>

<pre><span id="VALunsafe_set_bot"><span class="keyword">val</span> unsafe_set_bot</span> : <code class="type">'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a> -> Store.Ix.Set.t -> 'a <a href="Pomap_intf.POMAP.html#TYPEpomap">pomap</a></code></pre><div class="info ">
<code class="code">unsafe_set_bot pm set</code> updates the index of bottom nodes
      in map <code class="code">pm</code> with <code class="code">set</code>.  This assumes that the nodes referenced
      by the node indices in <code class="code">set</code> do not violate the properties of the
      Hasse-diagram of <code class="code">pm</code>.<br>
</div>
</body></html>