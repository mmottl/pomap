<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="POMAP : OCaml library for partially ordered maps" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>POMAP</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mmottl/pomap">View on GitHub</a>

          <h1 id="project_title">POMAP</h1>
          <h2 id="project_tagline">OCaml library for partially ordered maps</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mmottl/pomap/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mmottl/pomap/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="pomap---partially-ordered-maps-for-ocaml" class="anchor" href="#pomap---partially-ordered-maps-for-ocaml"><span class="octicon octicon-link"></span></a>POMAP - Partially Ordered Maps for OCaml</h1>

<hr><h2>
<a name="what-is-pomap" class="anchor" href="#what-is-pomap"><span class="octicon octicon-link"></span></a>What is <code>Pomap</code>?</h2>

<p>The Pomap-library maintains purely functional maps of partially ordered
elements.  Partially ordered maps are similar to partially ordered sets, but
map values for which a partial order relation is defined to some arbitrary
other values.  Here is an example for a partially ordered set to visualize
the idea:</p>

<p><img src="http://mmottl.github.io/pomap/hasse.png" alt="Hasse Diagram of a Partially Ordered Set" title="Hasse Diagram of a Partially Ordered Set"></p>

<p>Whereas total orders allow you to say whether some element is smaller than,
equal to, or greater than another one, partial orders also allow for a
"don't know"- or "undefined"-case.</p>

<p>Mathematically speaking, the axioms that hold for a partial order relation
are the following:</p>

<div class="highlight highlight-text"><pre>          x &lt;= x            (reflexivity)
x &lt;= y /\ y &lt;= x -&gt; x = y   (antisymmetry)
x &lt;= y /\ y &lt;= z -&gt; x &lt;= z  (transitivity)
</pre></div>

<p>Total orders, as usually used for "normal" maps that programmers are acquainted
with, would additionally require the following axiom:</p>

<div class="highlight highlight-text"><pre>x &lt;= y \/ y &lt;= x  (totality)
</pre></div>

<p>Whereas a total order allows you to align elements in a linear way to exhibit
this order relation (e.g. <code>[1; 3; 7; 42]</code>), partial orders are usually
represented by graphs (so-called Hasse-diagrams).  Here is another example:</p>

<div class="highlight highlight-text"><pre>                           (89,73)   (93,21)
                              |
                  (91,38)  (57,42)
                     |    /   |
                     |   /    |
                  (44,26)  (25,42)
                      \       /
                       (22,23)
</pre></div>

<p>The elements of this example partial order structure are pairs of integers.
We say that an element (a pair) is larger than another one if both of
its integers are larger then the respective integers in the other pair.
If both integers are smaller, then the pair is smaller, and if the two pairs
contain equal elements, they are equal.  If none of the above holds e.g. if
the first element of the first pair is smaller than the corresponding one
of the second pair and the second element of the first pair is greater than
its corresponding element of the second pair, then we cannot say that either
of the pairs is greater or smaller, i.e. the order is "unknown" (e.g. pairs
(44,26) and (25,42)).</p>

<p>Lines connecting elements indicate the order of the elements: the greater
element is above the smaller element.  Hasse-diagrams do not display the
order if it is implied by transitivity.  E.g. there is no separate line for
the elements (89,73) and (25,42).  If elements cannot be reached on lines
without reversing direction, then they cannot be compared.  E.g. the pair
(93,21) is incomparable to all others whereas (44,26) cannot be compared to
this latter pair and to (25,42) only.</p>

<p>This library internally represents relations between known elements similar
to Hasse-diagram.  This allows you to easily reason about or quickly manipulate
such structures.</p>

<p>Sounds too mathematical so far? There are many uses for such a library!</p>

<h3>
<a name="application-areas" class="anchor" href="#application-areas"><span class="octicon octicon-link"></span></a>Application areas</h3>

<h4>
<a name="data-mining" class="anchor" href="#data-mining"><span class="octicon octicon-link"></span></a>Data-mining</h4>

<p>Concept lattices obey rules similar to partial orders and can also be handled
using this library.  E.g., you might have a big e-commerce site with lots
of products.  For marketing purposes it would be extremely useful to know
product baskets that people frequently buy.  This is equivalent to asking
where in a Hasse-diagram such baskets might be placed.</p>

<p>Or imagine you develop a medical system that automatically associates different
mixes of medication with illnesses they effectively treat to support doctors
in deciding on a therapy.  This can all be addressed with concept lattices.</p>

<h4>
<a name="software-engineering" class="anchor" href="#software-engineering"><span class="octicon octicon-link"></span></a>Software engineering</h4>

<p>Refactoring software to reduce complexity is an important task for large
software projects.  If you have many different components that implement
many different features, you might want to know whether there are groups
of components that make use of specific features in other components.
You could then find out whether the current form of abstraction exactly
meets these dependencies, possibly learning that you should factor out a
set of features in a separate module to reduce overall complexity.</p>

<h4>
<a name="databases" class="anchor" href="#databases"><span class="octicon octicon-link"></span></a>Databases</h4>

<p>Partial order structures represented by Hasse-diagrams can be used to
optimize database queries on multi-valued attributes by providing better
ways of indexing.</p>

<h4>
<a name="general-problem-solving" class="anchor" href="#general-problem-solving"><span class="octicon octicon-link"></span></a>General problem-solving</h4>

<p>For general problem-solving we often need at least to know whether some
solution is better, equal to, worse or incomparable to another.  Given a
large number of known solutions, the partial order structure containing the
elements can be used to draw conclusions about e.g. whether their particular
form (syntax) implies anything about their position in the partial order
(semantic aspect).</p>

<h3>
<a name="what-advantages-does-this-particular-library-offer" class="anchor" href="#what-advantages-does-this-particular-library-offer"><span class="octicon octicon-link"></span></a>What advantages does this particular library offer?</h3>

<h4>
<a name="referential-transparency" class="anchor" href="#referential-transparency"><span class="octicon octicon-link"></span></a>Referential transparency</h4>

<p>The currently implemented functions all handle the data structure in a purely
functional way.  This allows you to hold several versions of a data structure
in memory while benefiting from structure sharing.  This makes backing out
changes to the data structure efficient and straightforward and also allows
you to use the library safely in a multi-threaded environment.</p>

<h4>
<a name="incremental-updates" class="anchor" href="#incremental-updates"><span class="octicon octicon-link"></span></a>Incremental updates</h4>

<p>Some algorithms only perform batch generation of Hasse-diagrams: once the
diagram has been computed, one cannot use such algorithms to add further
elements to it incrementally.  This library can handle incremental updates
(adding and removing of elements) fairly efficiently as required for
online-problems.</p>

<h4>
<a name="efficiency" class="anchor" href="#efficiency"><span class="octicon octicon-link"></span></a>Efficiency</h4>

<p>Both time and memory consumption seem suitable for practical problems,
even not so small ones.  Building up the Hasse-diagram for 1000 elements of
a moderately complex partial order should usually take less than a second
with native code on modern machines.</p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<h3>
<a name="api-documentation" class="anchor" href="#api-documentation"><span class="octicon octicon-link"></span></a>API-documentation</h3>

<p>Please refer to the API-documentation as programming reference, which
is built during installation with <code>make doc</code>.  It can also be found
<a href="http://mmottl.github.io/pomap/api">online</a>.</p>

<h3>
<a name="specification-of-the-partial-order-relation" class="anchor" href="#specification-of-the-partial-order-relation"><span class="octicon octicon-link"></span></a>Specification of the partial order relation</h3>

<p>All you need to provide is the function that computes the partial order
relation between two elements.  Take a look at the signature <code>PARTIAL_ORDER</code>
in file <code>lib/pomap_intf.ml</code>:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">module</span> <span class="k">type</span> <span class="nc">PARTIAL_ORDER</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">el</span>
  <span class="k">type</span> <span class="n">ord</span> <span class="o">=</span> <span class="nc">Unknown</span> <span class="o">|</span> <span class="nc">Lower</span> <span class="o">|</span> <span class="nc">Equal</span> <span class="o">|</span> <span class="nc">Greater</span>
  <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">ord</span>
<span class="k">end</span>
</pre></div>

<p>You only have to specify the type of elements of the partially ordered
structure and a comparison function that returns <code>Unknown</code> if the elements
are not comparable, <code>Lower</code> if the first element is lower than the second,
<code>Equal</code> when they are equal and <code>Greater</code> if the first element is greater
than the second one.  You can find example implementations of such modules
in directory <code>examples/hasse/po_examples.ml</code>.</p>

<h3>
<a name="creating-and-using-partially-ordered-maps" class="anchor" href="#creating-and-using-partially-ordered-maps"><span class="octicon octicon-link"></span></a>Creating and using partially ordered maps</h3>

<p>Given the specification, e.g. <code>MyPO</code>, of a partial order relation, we can
now create a map of partially ordered elements like this:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">module</span> <span class="nc">MyPOMap</span> <span class="o">=</span> <span class="nn">Pomap_impl</span><span class="p">.</span><span class="nc">Make</span><span class="o">(</span><span class="nc">MyPO</span><span class="o">)</span>
</pre></div>

<p>The interface specification <code>POMAP</code> in file <code>lib/pomap_intf.ml</code> documents in
detail all the functions that can be applied to partially ordered maps and
objects they maintain.  The important aspect is that information is stored in
nodes: you can access the key on which the partial order relation is defined,
the associated data element, the set of indices of successors and the set
of indices of predecessors.  Fresh indices are generated automatically for
new nodes.</p>

<p>Together with accessors to the indices of the bottommost and topmost nodes in
the partially ordered map, this allows for easy navigation in the associated
Hasse-diagram.</p>

<h3>
<a name="rendering-hasse-diagrams-using-the-dot-utility" class="anchor" href="#rendering-hasse-diagrams-using-the-dot-utility"><span class="octicon octicon-link"></span></a>Rendering Hasse-diagrams using the dot-utility</h3>

<p>The Pomap-library also contains modules that allow you to easily render
Hasse-diagrams given some partially ordered map and pretty-printing
functions for elements.  This requires installation of the
<a href="http://www.graphviz.org">Graphviz</a> package, which supplies the needed
<code>dot</code>-utility.  The use of these modules is demonstrated in the distributed
<code>hasse</code>-example, which comes with its own README.</p>

<hr><h2>
<a name="contact-information-and-contributing" class="anchor" href="#contact-information-and-contributing"><span class="octicon octicon-link"></span></a>Contact Information and Contributing</h2>

<p>In the case of bugs, feature requests, contributions and similar, you can
contact me here: <a href="mailto:markus.mottl@gmail.com">markus.mottl@gmail.com</a></p>

<p>Up-to-date information should be available at: <a href="http://mmottl.github.io/pomap">http://mmottl.github.io/pomap</a></p>

<p>Enjoy!</p>

<p>Markus Mottl on July 10, 2012</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">POMAP maintained by <a href="https://github.com/mmottl">mmottl</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
