{"name":"POMAP","tagline":"OCaml library for partially ordered maps","body":"POMAP - Partially Ordered Maps for OCaml\r\n========================================\r\n\r\n---------------------------------------------------------------------------\r\n\r\nWhat is `Pomap`?\r\n----------------\r\n\r\nThe Pomap-library maintains purely functional maps of partially ordered\r\nelements.  Partially ordered maps are similar to partially ordered sets, but\r\nmap values for which a partial order relation is defined to some arbitrary\r\nother values.  Here is an example for a partially ordered set to visualize\r\nthe idea:\r\n\r\n  ![Hasse Diagram of a Partially Ordered Set](http://mmottl.github.io/pomap/hasse.png \"Hasse Diagram of a Partially Ordered Set\")\r\n\r\nWhereas total orders allow you to say whether some element is smaller than,\r\nequal to, or greater than another one, partial orders also allow for a\r\n\"don't know\"- or \"undefined\"-case.\r\n\r\nMathematically speaking, the axioms that hold for a partial order relation\r\nare the following:\r\n\r\n```text\r\n          x <= x            (reflexivity)\r\nx <= y /\\ y <= x -> x = y   (antisymmetry)\r\nx <= y /\\ y <= z -> x <= z  (transitivity)\r\n```\r\n\r\nTotal orders, as usually used for \"normal\" maps that programmers are acquainted\r\nwith, would additionally require the following axiom:\r\n\r\n```text\r\nx <= y \\/ y <= x  (totality)\r\n```\r\n\r\nWhereas a total order allows you to align elements in a linear way to exhibit\r\nthis order relation (e.g. `[1; 3; 7; 42]`), partial orders are usually\r\nrepresented by graphs (so-called Hasse-diagrams).  Here is another example:\r\n\r\n```text\r\n                           (89,73)   (93,21)\r\n                              |\r\n                  (91,38)  (57,42)\r\n                     |    /   |\r\n                     |   /    |\r\n                  (44,26)  (25,42)\r\n                      \\       /\r\n                       (22,23)\r\n```\r\n\r\nThe elements of this example partial order structure are pairs of integers.\r\nWe say that an element (a pair) is larger than another one if both of\r\nits integers are larger then the respective integers in the other pair.\r\nIf both integers are smaller, then the pair is smaller, and if the two pairs\r\ncontain equal elements, they are equal.  If none of the above holds e.g. if\r\nthe first element of the first pair is smaller than the corresponding one\r\nof the second pair and the second element of the first pair is greater than\r\nits corresponding element of the second pair, then we cannot say that either\r\nof the pairs is greater or smaller, i.e. the order is \"unknown\" (e.g. pairs\r\n(44,26) and (25,42)).\r\n\r\nLines connecting elements indicate the order of the elements: the greater\r\nelement is above the smaller element.  Hasse-diagrams do not display the\r\norder if it is implied by transitivity.  E.g. there is no separate line for\r\nthe elements (89,73) and (25,42).  If elements cannot be reached on lines\r\nwithout reversing direction, then they cannot be compared.  E.g. the pair\r\n(93,21) is incomparable to all others whereas (44,26) cannot be compared to\r\nthis latter pair and to (25,42) only.\r\n\r\nThis library internally represents relations between known elements similar\r\nto Hasse-diagram.  This allows you to easily reason about or quickly manipulate\r\nsuch structures.\r\n\r\nSounds too mathematical so far? There are many uses for such a library!\r\n\r\n### Application areas\r\n\r\n####  Data-mining\r\n\r\nConcept lattices obey rules similar to partial orders and can also be handled\r\nusing this library.  E.g., you might have a big e-commerce site with lots\r\nof products.  For marketing purposes it would be extremely useful to know\r\nproduct baskets that people frequently buy.  This is equivalent to asking\r\nwhere in a Hasse-diagram such baskets might be placed.\r\n\r\nOr imagine you develop a medical system that automatically associates different\r\nmixes of medication with illnesses they effectively treat to support doctors\r\nin deciding on a therapy.  This can all be addressed with concept lattices.\r\n\r\n#### Software engineering\r\n\r\nRefactoring software to reduce complexity is an important task for large\r\nsoftware projects.  If you have many different components that implement\r\nmany different features, you might want to know whether there are groups\r\nof components that make use of specific features in other components.\r\nYou could then find out whether the current form of abstraction exactly\r\nmeets these dependencies, possibly learning that you should factor out a\r\nset of features in a separate module to reduce overall complexity.\r\n\r\n#### Databases\r\n\r\nPartial order structures represented by Hasse-diagrams can be used to\r\noptimize database queries on multi-valued attributes by providing better\r\nways of indexing.\r\n\r\n#### General problem-solving\r\n\r\nFor general problem-solving we often need at least to know whether some\r\nsolution is better, equal to, worse or incomparable to another.  Given a\r\nlarge number of known solutions, the partial order structure containing the\r\nelements can be used to draw conclusions about e.g. whether their particular\r\nform (syntax) implies anything about their position in the partial order\r\n(semantic aspect).\r\n\r\n### What advantages does this particular library offer?\r\n\r\n#### Referential transparency\r\n\r\nThe currently implemented functions all handle the data structure in a purely\r\nfunctional way.  This allows you to hold several versions of a data structure\r\nin memory while benefiting from structure sharing.  This makes backing out\r\nchanges to the data structure efficient and straightforward and also allows\r\nyou to use the library safely in a multi-threaded environment.\r\n\r\n#### Incremental updates\r\n\r\nSome algorithms only perform batch generation of Hasse-diagrams: once the\r\ndiagram has been computed, one cannot use such algorithms to add further\r\nelements to it incrementally.  This library can handle incremental updates\r\n(adding and removing of elements) fairly efficiently as required for\r\nonline-problems.\r\n\r\n#### Efficiency\r\n\r\nBoth time and memory consumption seem suitable for practical problems,\r\neven not so small ones.  Building up the Hasse-diagram for 1000 elements of\r\na moderately complex partial order should usually take less than a second\r\nwith native code on modern machines.\r\n\r\nUsage\r\n-----\r\n\r\n### API-documentation\r\n\r\nPlease refer to the API-documentation as programming reference, which\r\nis built during installation with `make doc`.  It can also be found\r\n[online](http://mmottl.github.io/pomap/api).\r\n\r\n### Specification of the partial order relation\r\n\r\nAll you need to provide is the function that computes the partial order\r\nrelation between two elements.  Take a look at the signature `PARTIAL_ORDER`\r\nin file `lib/pomap_intf.ml`:\r\n\r\n```ocaml\r\nmodule type PARTIAL_ORDER = sig\r\n  type el\r\n  type ord = Unknown | Lower | Equal | Greater\r\n  val compare : el -> el -> ord\r\nend\r\n```\r\n\r\nYou only have to specify the type of elements of the partially ordered\r\nstructure and a comparison function that returns `Unknown` if the elements\r\nare not comparable, `Lower` if the first element is lower than the second,\r\n`Equal` when they are equal and `Greater` if the first element is greater\r\nthan the second one.  You can find example implementations of such modules\r\nin directory `examples/hasse/po_examples.ml`.\r\n\r\n### Creating and using partially ordered maps\r\n\r\nGiven the specification, e.g. `MyPO`, of a partial order relation, we can\r\nnow create a map of partially ordered elements like this:\r\n\r\n```ocaml\r\nmodule MyPOMap = Pomap_impl.Make(MyPO)\r\n```\r\n\r\nThe interface specification `POMAP` in file `lib/pomap_intf.ml` documents in\r\ndetail all the functions that can be applied to partially ordered maps and\r\nobjects they maintain.  The important aspect is that information is stored in\r\nnodes: you can access the key on which the partial order relation is defined,\r\nthe associated data element, the set of indices of successors and the set\r\nof indices of predecessors.  Fresh indices are generated automatically for\r\nnew nodes.\r\n\r\nTogether with accessors to the indices of the bottommost and topmost nodes in\r\nthe partially ordered map, this allows for easy navigation in the associated\r\nHasse-diagram.\r\n\r\n### Rendering Hasse-diagrams using the dot-utility\r\n\r\nThe Pomap-library also contains modules that allow you to easily render\r\nHasse-diagrams given some partially ordered map and pretty-printing\r\nfunctions for elements.  This requires installation of the\r\n[Graphviz](http://www.graphviz.org) package, which supplies the needed\r\n`dot`-utility.  The use of these modules is demonstrated in the distributed\r\n`hasse`-example, which comes with its own README.\r\n\r\n---------------------------------------------------------------------------\r\n\r\nContact Information and Contributing\r\n------------------------------------\r\n\r\nIn the case of bugs, feature requests, contributions and similar, you can\r\ncontact me here: <markus.mottl@gmail.com>\r\n\r\nUp-to-date information should be available at: <http://mmottl.github.io/pomap>\r\n\r\nEnjoy!\r\n\r\nMarkus Mottl on July 10, 2012\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}